# Epsilon Security Project

This is a guide to understanding various aspects of the Epsilon Security Project. It is expected to be the definitive reference for Project Structure, Setup, and Deployment procedure. As such, this document should be treated as a living standard open to updates as the need arises.

## Project Structure

The entire project is _conceptually_ composed of 2 subprojects:

1. The **Backend**: provides REST API endpoints for performing CRUD operations on the database.
2. The **Frontend**: provides a single-page-app with the neccessary HTML, CSS, and Javascript. It then accesses the API endpoints provided by the Backend to enable users do useful things. 

However the Frontend is _physically_ located inside the Backend as illustrated below:

		/                 *root of backend subproject
		  app/
		  conf/
		  public/
		  front/          *the frontend subproject*
		  build.sbt
		  ...

_This distinction is very important, and will guide further discussions._

The frontend is located inside the backend so that we can easily deploy both by zipping up the root directory as we shall see later.

## Quick Start

### Requirements

Although the frontend is inside the backend as previously mentioned, they are very different and have different tooling requirements. The backend is powered by _Play_ while the frontend is powered by _Node.js_. Hence you need to have both the Play and Node environments setup on your machine. 

1. Install _sbt_ - The Scala Build Tool, for building the backend. SBT depends on Java so ensure you have Java installed.
2. Install _npm_ - The Node Package Manager, for building the frontend. NPM depends on Node.js so ensure you have Node installed.

### Development mode

To run the app in development mode:
1. Install dependencies of the frontend app (_you only need to do this once - and of course everytime you add a new dependency_)
```
cd front && npm install
```
2. Now build the backend using
```
cd .. && sbt run
```
This will spin up the Play server to run the backend, and also the _webpack-dev-server_ to run the frontend. If everything goes fine, you should be able to access the app at `http://localhost:9000`

### Production Mode

To run the app in production mode, simply run the command
```
sbt dist
```
This will build your frontend app and bundle it with your backend app to finally produce a zip archive that can be deployed on a server.

## How it really works:

### Building for development:

When you execute `sbt run`, Play runs in dev mode and allows you to hookup additional processes useful for development - in our case, we want to hookup a frontend server which will serve our frontend app. To achieve this, we need to create an object in the _/project/_ directory that extends `PlayRunHook`

The file `WebpackServer.scala` does exactly this: it add 2 hooks for when Play runs in dev mode.

1. A hook to run our frontend app **after Play has started**. To be precise, it spins off a _webpack-dev-server_ to serve our frontend app by executing the command `npm run watch -- --port $port` on the frontend directory. `$port` is the localhost port that the frontend server will be listening on - we specify this in the file `/conf/frontend.conf`
2. It adds another hook to kill all the processes it started **after Play stops**. To be precise, it kills the _web-dev-server_ process it started at _(1)_

See [here](https://www.playframework.com/documentation/2.6.x/SBTCookbook) for more info on how Play dev mode works.

### Building for production:

When you execute `sbt dist`, Play compiles and bundles up all your app assets into a zip file that can deployed on a server. We can extend this command to allow us build our frontend app for production first, so the zip generated by `dist` also includes our frontend code.

In the _build.sbt_ file, we add 3 commands that collectively extend the `dist` command to first build our frontend app for production before wrapping up everything.

1. `cleanFrontEndBuild`: this deletes all the files in our build directory (_public/bundle_) - this removes any old bundled css and js files.
2. `frontEndBuild`: this does three things:
	1. First it cleans our build directory by calling `cleanFrontEndBuild`.
	2. Then it executes `npm install` on our frontend directory - to install the dependencies of our frontend.
	3. Finally, it executes `npm run build` on our frontend directory - to bundle up our css and js assets for production.
3. `dist`: simply calls `frontEndBuild`, before doing its orginal job of generating a zipping the entire project.

See [here](https://www.playframework.com/documentation/2.6.x/Deploying) for more info on how Play production mode works.

## Details about the Frontend

In the frontend directory, there is a _package.json_ with configurations that _npm_ (the Node.js build tool) will use to build our project. we define 2 commands that will build our project in either development or production mode. 

### Development mode
The `npm run watch` command uses _Webpack_ and the default webpack config file _webpack.config.js_ to build our frontend. The configurations in this file have the following effect:
	
1. Bundles all our js files into a single _build.js_ file and saves it in the _../public/js_ directory.
2. Runs a frontend server (the _webpack-dev-server_) that serves the frontend files. the dev server hot-reloads our app, i.e, it watches our files and updates any parts of the page that changes without refreshing the entire page.
3. Enables sourcemaps so we can see the actual file and line number that an error occured. Without sourcemaps, it hard to tell which file contains an because webpack has bundled them all up into a single file.

### Production mode
The `npm run build` command uses _Webpack_ and the _webpack.production.config.js_ config file to build our frontend. The configurations in this file have the following effect:

1. Bundles all .js files into a _js.bundle.<hash>.js_ file and save it in the '../public/bundle' directory - Play can find it there.
2. The hash in our bundle file name is for cache-bursting - so every production release is unique, consequently causing the browser to download the latest code.
3. Also specifies that css and js files should be minified before bundling, and the bundle should be further compressed.

### (Just so you know) Issues with compression.

In production mode, we let webpack compress our js and css bundles using the _compression-webpack-plugin_ (see _webpack.production.config.js_ line 54). the compression uses the gzip format by default so the resultant files have a .gz extension.

However, you cannot include a gzipped css or js asset directly in HTML files (i.e, you cannot have `<script src="bundle.js.gz">`), so we create a utility object in _/app/lib/WebpackBuildFile.scala_ to strip-out the `.gz` extension from our compressed file before including them in our HTML files. The result is that our HTML files have includes like `<script src="bundle.js">` but the server actually serves `bundle.js.gz`.

All these extraneous work could be avoided by simply not compressing the production bundles, but keep in mind, gzip has been shown to yeild significant reductions in file sizes so this optimization is worth it.